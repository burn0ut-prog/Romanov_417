#include <iostream>
#include <locale.h>
#include <iomanip>
#include <bitset>
#include <cmath>



//транспонирование

//умножение, делениеи прсосоклром
// умножение 2матриц

//умножение2 матричматричное
//умножение матрицы на вектор
//скалярное умножениематрицы на веектор
// векторное умножение двухвекторов
//Подсчёт определителя матрицы 
void dinamic(int** array, int& row_count, int& col_count)
{
	std::cin >> row_count;
	std::cin >> col_count;
	array = new int* [row_count];
	for (int row = 0; row < row_count; row++)
	{
		array[row] = new int[col_count];

	}
	for (int row = 0; row < row_count; row++)
	{
		for (int col = 0; col < col_count; col++)
		{
			std::cin >> array[row][col];

		}

		std::cout << std::endl;
	}


}
int main(void)
{
	setlocale(LC_ALL, "Russian");
	double matrix[3][3] = { 0 };
	std::cout << "Введите тип матрицы постолбцами строкам" << std::endl;
	for (int row = 0; row < 3; row++)
	{
		for (int col = 0; col < 3; col++)
		{
			std::cout << "строка " << row << ",строка " << col;
			std::cin >> matrix[row][col];
		}
	}
	std::cout << "Матрица" << std::endl;
	for (int row = 0; row < 3; row++)
	{
		for (int col = 0; col < 3; col++)
		{

			std::cout << matrix[row][col] << " ";
		}
		std::cout << std::endl;
	}
	double det;
	for (int i = 0; i < 1; i++)
	{
		int det = matrix[0][0] * matrix[1][1] * matrix[2][2] - matrix[0][0] * matrix[1][2] * matrix[2][1]
			- matrix[0][1] * matrix[1][0] * matrix[2][2] + matrix[0][1] * matrix[1][2] * matrix[2][0]
			+ matrix[0][2] * matrix[1][0] * matrix[2][1] - matrix[0][2] * matrix[1][1] * matrix[2][0];
		std::cout << "Определитель матрицы: " << det << std::endl;
	}
	std::cout << std::endl;






	/*Динамическая память (C++)
	Определение
	Локальные переменные, обявляемые до этого в main и других функциях называются стековыми (т.к. переменные, объявляемые в фукнции, создаются в специальной области памяти приложения, называемой стеком (stack)).
	Как правило не вся ОП занята приложением, и в распоряжении ОС есть некоторый объём нераспределённой памяти (англ. heap - куча). Приложение может запросить выделить блок динамической памяти. Если свободной памяти достаточно, ОС “закрепляет” блок нераспределённой памяти за приложением, и передаёт приложению указатель от неё.
	При остановке приложения ОС автоматически освобождает выделенную динамическую память. Однако если уже в процессе работы приложения переменная в динамической памяти больше не нужна, то её нужно освободить, т.к. динамическая память небезграничная, и используется также другими приложениями. Неконтролируемое выделение динамической памяти приложением без её освобождения называется утечкой памяти.
	Синтаксис
	Выделение переменной типа  в динамической памяти

	тип_данных * имя_указателя = new тип_данных;
	Освобождение выделенной переменной
	delete имя_указателя;
	С этого момента пользоваться указателем нельзя. Попытка воспользоваться указателем имя_указателя приведёт к ошибке.

	Примеры:
	выделение числа с плавающей точкой в динамической памяти:
	double * ptr_double = new double;
	выделение массива в динамической памяти, в отличие от стекового, позволяет задавать длину переменной, а не константой:
	int array_len = 10;
	double * ptr_double_1Darray = new double[array_len];
	Выделить в одно действие массив размерностью более 1 нельзя. При выделении двумерного массива в динамической памяти необходимо сначала создать массив указателей на строчки (одномерные массивы), а затем выделить память под каждую строчку (одномерный массив)
	int num_of_cols = 100, num_of_rows = 100;
	double ** ptr_double_2Darray = new double*[num_of_rows]; // указатель на массив указателей на строки (1D массивы)
	for(int row = 0; row < num_of_rows; i++)
	{
		ptr_double_2Darray[row] = new double[num_of_cols]; // выделение памяти под строку - одномерный массив
		ptr_double_2Darray[row][col] = ...; // здесь можно провести инициализацию массива - задание начальных значений
	}
	Освобождение памяти единичной переменной полностью описывается в разделе синтаксиса, и приводить пример не имеет смысла.
	Освобождение памяти одномерного массива:
	delete[] ptr_double_1Darray;
	Освобождение памяти двумерного массива зеркально по отношению к выделению памяти: сначала нужно освободить одномерные массивы отдельных строк, а затем - массив указателей на строки:
	for(int row = 0; row < num_of_rows; row++)
	{
		delete[] ptr_double_2Darray[row];
	}
	delete[] ptr_double_2Darray;
	Применение
	Размер стека ограничен. Большие объёмы данных, превышающие допустимый размер стека, выделяются именно в динамической памяти:
	таблицы для bigdata-аналитики,
	трёхмерные модели и текстуры игрового ландшафта,
	расчётные сетки инженерных систем и пр.
	Динамическая память позволяет создавать массивы с длиной, заданной не константой при компиляции, а переменной. Именной той длины, которой нужно в данный момент приложению.
	Задания
	Задания выполняются самостоятельно, без заимствования фрагментов кода из сторонних источников (можно использовать для подготовки любую информацию, но нельзя копировать в свой код)
	Создать переменную в динамической памяти.
	Создать и проинициализировать (в отдельном цикле) одномерный массив в динамической памяти.
	Создать и проинициализировать (в цикле) двумерный массив в динамической памяти.
	Вызвать утечку памяти, выделяя динамическую переменную в цикле. Пронаблюдать за выделением оперативной памяти в диспетчере задач.
	Прописать в программе освобождение всех переменных и массивов, выделенных в динамической памяти.
	Создать новый проект, перенести в него код по матричной арифметике из прошлого задания (21.10.2020), но стековые массивы заменить динамическими, а также предусмотреть ввод размерностей массивов с клавиатуры в диалоге.
	Функции
	Определение
	Функция - фрагмент кода
	который может быть вызван из другого места в коде многократно,
	[не обязательно] имеющий собственное имя,
	[не обязательно] выполняющий законченное по смыслу действие,
	[не обязательно] который может получать данные/параметры извне (из вызвавшего кода),
	[не обязательно] который может возвращать обработанные данные после завершения своей работы.
	Синтаксис
	Объявление функции (по факту, её заголовок)
	возвращаемый_тип имя_функции(тип1 параметр1, тип2 параметр2, ...);
	Определение функции (заголовок + сам код функции). Параметры, которые являются исходными данными для функции, перечисляются через запятую в круглых скобках. Значение, которое функция должна вернуть после обработки, указывается после ключевого слова return:
	возвращаемый_тип имя_функции(тип1 параметр1, тип2 параметр2, ...)
	{
		// объявление переменных
		// код функции
		return значение;
	}
	Чтобы воспользоваться функцией, в коде пишется её имя и перечисляются входные параметры через запятую:
	... // где-то в коде
	переменная имя_функции(параметр1, параметр2, ...)

	Пример функции, которая рассчитывает и возвращает произведение двух аргументов:
	double function_multiply(int p1, double p2) // функция объявлена и определена перед её вызовом
	{
		return p1 * p2;
	}
	...// где-то в коде
	int argument1 = 10;
	double argument2 = 55.2;
	double result;
	result = function_multiply(argument1, argument2 ); // теперь result - это то, что вернул return

	Функция должна быть объявлена перед её первым вызовом в коде.
	Определение функции не обязательно должно быть перед её первым вызовом в коде.
	Функция не обязательно должна возвращать значение. К примеру, функция для отображения диалогового окна, функция для записи порции данных в файл, функция для транспонирования матрицы может не возвращать значение. Синтаксис функции, которая не имеет возвратного значения (void - пустой тип, отсутствие типа):
	void function2(int p1, string p2)
	{
		int a;
		// код записи строки p2 на строку p1 в файл
		// использование return здесь приведёт к ошибке
	}
	Все переменные, объявленные внутри функции, как  параметры со своими именами, видны и существуют только внутри функции.
	Параметры (в скобках) являются по сути копиями значений, которые передавались в фукнцию в момент вызова. Вы можете их изменить внутри функции, но оригиналы (переменные и константы) не изменятся:
	double function1(int p1, double p2) // функция объявлена и определена перед её вызовом
	{
		p1 = p1 + 1; // значение p1 внутри функции поменяется, но значение argument2, который передавался как второй параметр, снаружи функции не поменяется
		return p1 * p2;
	}
	...// где-то в коде
	int argument1 = 10;
	double argument2 = 55.2;
	double result;
	result = function1(argument1, argument2 ); // значение argument2 здесь не поменяется от того, что параметр меняется в функции

	В C/C++ через return в отличие от python можно возвращать только один параметр.
	Если необходимо из функции вернуть более одного значения, второе и последующее значение возвращаются через параметры, помеченные как указатели “*” или как параметры  по ссылке “&”:

	int function1(int p1, int & p2, int * p3)
	{
		p2 = p2 + 10; // переменная, которая передавалась как p2 также изменится снаружи функциии, её можно использовать как дополнительный выходной параметр помимо return
		*p3 = *p3 + 1; // переменная, которая передавалась по указателю p3, также изменится снаружи функции, её можно использовать как дополнительный выходной параметр помимо return
		return p1 + 100; // обычный единственный выходной параметр через return
	}
	... // где-то в коде
	int result1
	int result2 = 20; // и входной, и выходной параметр
	int result3 = 1;
	int * ptr_result3 = &result3 ;
	result1 = function1(10, result2, ptr_result3);
	// к этому моменту result1 == 110, result2 == 30, result3 ==2
	Заголовок функции, в которую передаётся одномерный массив, выглядит как
	int function1(int array1D[]);
	или
	int function1(int *array1D);
	или
	int function1(int array1D[размер]);
	Заголовок функции, в которую передаётся двумерный массив, выглядит как
	int function1(int array2D[размерM][размерN]);
	(если оба размера определены), или
	int function1(int array2D[размерM][]);
	если определён один из размеров, или без указания размерностей
	int function1(int **array2D);
	или, аналогично,
	int function1(int *array2D[]);
	Применение
	Фрагменты кода оформляются как функции, если необходимо
	Их частое повторное использование;
	Логическое разбиение большого кода на более мелкие фрагменты для облегчения восприятия и читаемости;
	Для обеспечения модульности кода (одну функцию легко заменить другой).
	Задания
	Задания выполняются самостоятельно, без заимствования фрагментов кода из сторонних источников (можно использовать для подготовки любую информацию, но нельзя копировать в свой код)
	Из задания по матричной арифметике вынесите в отдельные функции код
	в котором производится ввод значений матрицы и вектора (в отдельные функцию). Дайте функциям осмысленные имена. Функция должна возвращать введённую матрицу, а также его длину и высоту через параметр по ссылке. Пример объявления функции:
	void input_matrix(double ** array, int & row_number, int & col_number);
	в котором выполняется матричное арифметическое действие по вашему варианту. Пример заголовка фукнции для варианта с умножением двух матриц:
	void mat_multiply(double ** array1, int & row_number1, int & col_number1, double ** array2, int & row_number2, int & col_number2)
	В котором выполняется печать. Пример заголовка функции для печати матрицы
	void print_matrix(double ** matrix, int row_number, int col_number);
	Фрагменты кода, выполнявшие перечисленные действия в вашем варианте, замените вызовами соответствующих созданных функций. Проведите тестирование приложения. Оно должно собираться, работать и правильно выполнять прежние расчёты по варианту.*/











	std::system("pause");
	return 0;
}